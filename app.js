require('dotenv').config()
const client = require('ari-client')
const dgram = require('dgram')
const server = dgram.createSocket('udp4')
const mqtt = require('mqtt')

const ariApp = 'schranka'

class AriController {
  channels = []

  constructor(options) {
    this.options = Object.assign({}, options)
    this.connect()
  }

  async connect() {
    this.ari = await client.connect(process.env.AST_HOST, process.env.AST_USER, process.env.AST_PASS)
    this.ari.once('StasisStart', channelJoined)

    function channelJoined(event, incoming) {
      console.log("Someone is ringing the bell")
      incoming.answer()
    }

    this.ari.start(ariApp)
  }

  async close() {
    if (this.closing) {
      return
    }
    this.closing = true

    for (var i = 0; i < this.channels.length; i++) {
      if (this.channels[i]) {
        console.log("Hanging up channel", this.channels[i].id)
        try {
          await this.channels[i].hangup()
        } catch (error) {
        }
        delete this.channels[i]
      }
    }
    this.channels = []

    if (this.microphoneChannel) {
      console.log("Hanging up microphone media channel")
      try {
        await this.microphoneChannel.hangup()
      } catch (error) {
      }
      delete this.microphoneChannel
    }

    if (this.speakerChannel) {
      console.log("Hanging up speaker media channel")
      try {
        await this.speakerChannel.hangup()
      } catch (error) {
      }
      delete this.speakerChannel
    }

    if (this.bridge) {
      console.log("Destroying bridge")
      try {
        await this.bridge.destroy()
      } catch (error) {
      }
      delete this.bridge
    }
  }

  async zazvon() {
    // Create bridge
    this.bridge = this.ari.Bridge()
    try {
      await this.bridge.create({ type: "mixing" })
    } catch (error) {
      console.error(error)
      this.close()
    }
    this.bridge.on('BridgeDestroyed', (event) => {
      this.close()
    })

    this.options.dialstring.forEach(element => {
      this.originate(element)
    })
    // Now we create the External Media channel for microphone
    this.extChannel = this.ari.Channel()
    this.extChannel.on('StasisStart', (event, chan) => {
      chan.getChannelVar({
        channelId: chan.id,
        variable: "UNICASTRTP_LOCAL_PORT"
      }).then((port) => {
        this.extMediaMicPort = parseInt(port.value)
        var client = dgram.createSocket('udp4');
        server.on('message', (msg, rinfo) => {
          client.send(msg, 0, msg.length, this.extMediaMicPort, process.env.THIS_HOST)
        })
        
      })
      this.bridge.addChannel({ channel: chan.id })
    })
    this.extChannel.on('StasisEnd', (event, chan) => {
      this.close()
    })

    try {
      let resp = await this.extChannel.externalMedia({
        app: ariApp,
        external_host: this.options.externalHost,
        connection_type: "server",
        format: "ulaw",
        direction: "both"
      })
    } catch (error) {
      console.log(error)
      this.close()
    }

    this.bot()
  }

  async originate(dialString) {
    var ch = this.ari.Channel()
    this.channels.push(ch)
    ch.on('StasisStart', (event, chan) => {
      console.log("Adding", dialString, "to bridge")
      this.bridge.addChannel({ channel: chan.id })
    })
    ch.on('StasisEnd', (event, chan) => {
      this.close()
    })
    try {
      await ch.originate({
        endpoint: dialString,
        formats: 'ulaw',
        app: ariApp,
        callerId: process.env.CALLER_ID
      })
    } catch (error) {
      this.close()
    }
  }

  async bot() {

    this.ari.bridges.play({
      bridgeId: this.bridge.id,
      media: 'sound:zvonek-odezva'
    })
      .then(function (playback) { })
      .catch(function (err) { console.log(err) })

    //TODO docasne, at to closne bot
    setTimeout(() => {
      this.close()
    }, 60000)

  }
}

/*
externalHost: Host and port where to send UPD for speaker. Listen port for microphone is autogenerated.
*/
var ariController = new AriController({
  dialstring: JSON.parse(process.env.RING_TO_JSON),
  externalHost: process.env.SPEAKER_UDP_HOST_PORT,
})


//Listen for UDP packets from mic
server.on('error', (err) => {
  console.log(`server error:\n${err.stack}`)
  server.close();
})
server.on('listening', () => {
  const address = server.address()
  console.log(`UDP server listening ${address.address}:${address.port}`)
})
server.bind(parseInt(process.env.MIC_STATIC_UDP_PORT))

var mqClient  = mqtt.connect(process.env.MQTT_HOST, {username: process.env.MQTT_USER, password: process.env.MQTT_PASS})
mqClient.on('connect', function () {
  mqClient.subscribe(process.env.MQTT_TOPIC, function (err) {
    if (!err) {
      console.log("Subscribed to", process.env.MQTT_TOPIC, "MQTT topic")
    }
    else {
      console.log("MQTT error", err)
    }
  })
})
 
mqClient.on('message', function (topic, message) {
  // message is Buffer
  var msg = message.toString()
  console.log('schranka/zvonek', msg, ariController.bridge)
  if (msg === 'on' && ariController.bridge === undefined) {
    ariController.zazvon()
  }
})
